// Includes Python to JavaScript syntax and language notes
// multi-arm bandit (slot machine) simulation
// strategy: "win-stay, lose-switch" with an epsilon-greedy algo used when switching

class SlotMachine {
    // constructor() vs. def __init__(self): in Python
    // this. vs self.
    // { } instead of spaces/indents
    // ; at the end of every statement that gets executed
    constructor(probability) {
      this.probability = probability;
      this.totalPulls = 0;
      this.totalWins = 0;
    }
    
    // pull() method does not need def in front or pull(self)
    pull() {
      this.totalPulls++; // += 1
      return Math.random() < this.probability; // will return true if the Random Var is less
    }
  }
  
function initializeSlotMachines(numMachines, minProbability, maxProbability) {
    const machines = []; // note: with const you can update the contents of the array with .push(), but you can't redefine it
    // for loop is uglier than Python (initalize the index, set the bound, and tell what to do at the end of each iteration i++ is i += 1)
    for (let i = 0; i < numMachines; i++) {
        // const probability = Math.random() * (maxProbability - minProbability) + minProbability;
        const probability = i/numMachines;
        // .push() vs .append()
        // The new keyword first creates a new empty object. Then, it binds the newly created object to the prototype of the constructing function. 
        machines.push(new SlotMachine(probability)); // new is needed when creating a user-defined or built-in object
    }
    // console.log("machines", machines);
    return machines;
}
  
function winStayLoseSwitch(numPulls, machines) {
    const chosenMachineIndices = [];
    let totalWins = 0; //mutable; block-scoped as compared with var
    let didWin;
    let chosenMachineIndex = 0; // define here for use elsewhere within scope
  
    for (let i = 0; i < numPulls; i++) {
      // Choose a machine based on win-stay, lose-switch strategy
      if (i === 0) {
        // do nothing
        // console.log("no change on initial index");
      } else if (!didWin) {
        // filter: callback (arrow function used =>) function/predicate (function w/ true false output) applied to each element in array; element(not used _) and index
        const nonChosenMachines = machines.filter((_, index) => index !== chosenMachineIndices[i - 1]);
        // chosenMachineIndex = machines.indexOf(getMaxProbabilityMachine(nonChosenMachines, epsilon=(1 - i/numPulls)));
        chosenMachineIndex = machines.indexOf(getMaxProbabilityMachine(nonChosenMachines, epsilon=0.05));
        // console.log("New Index:", chosenMachineIndex);
      } else if (didWin) {
        // console.log("don't update the chosenMachineIndex", chosenMachineIndex);
      }
  
      // Pull the chosen machine
      didWin = machines[chosenMachineIndex].pull();
  
      // Update statistics
      chosenMachineIndices.push(chosenMachineIndex);
      if (didWin) {
        machines[chosenMachineIndex].totalWins++;
        totalWins++;
      }
    }
  
    return totalWins;
}
  
function getMaxProbabilityMachine(machines, epsilon = 0.5) {
    // .reduce() also iterates over an array, but it returns a single value
    // accumulator (accumulates returned value) and current value are the two vars. Optional vars include initial accumulator value.
    // similar to, but more general than max() or sum() in python
    if (Math.random() > epsilon) {
        // console.log("greedy choice");
        return machines.reduce((maxMachine, currentMachine) => maxMachine.probability > currentMachine.probability ? maxMachine : currentMachine);
    } else {
        // console.log("non-greedy exploration on top of the switching policy");
        return machines[Math.floor(Math.random() * machines.length)];
    }      
  }
  
// Example usage
const numMachines = 10;
const minProbability = 0.1;
const maxProbability = 0.9;
const numPulls = 10000;

const slotMachines = initializeSlotMachines(numMachines, minProbability, maxProbability);
const totalWins = winStayLoseSwitch(numPulls, slotMachines);

console.log(`win-stay, lose-switch success rate: ${totalWins/numPulls}`);
//   console.log("types of attributes in list of objects", slotMachines.map(val => typeof(val.probability)));
console.log(`slot machine difficulty metric (average likelihood of machine payoff): ${slotMachines.reduce((acc, val) => acc + val.probability, 0)/slotMachines.length}`);
console.log(slotMachines);
